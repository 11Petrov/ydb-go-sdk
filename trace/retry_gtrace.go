// Code generated by gtrace. DO NOT EDIT.

package trace

import (
	"context"
	"fmt"
	"io"
	"os"
	"runtime/debug"
)

// retryComposeOptions is a holder of options
type retryComposeOptions struct {
	recoverPanic       bool
	exitCodeOnPanic    *int
	recoverPanicWriter io.Writer
}

// RetryOption specified Retry compose option
type RetryComposeOption func(o *retryComposeOptions)

// WithRetryRecoverPanic specified behavior on panic - recover or not
func WithRetryRecoverPanic(b bool) RetryComposeOption {
	return func(o *retryComposeOptions) {
		o.recoverPanic = b
	}
}

// WithRetryRecoverPanicWriter specified writer for print panic details
func WithRetryRecoverPanicWriter(w io.Writer) RetryComposeOption {
	return func(o *retryComposeOptions) {
		o.recoverPanicWriter = w
	}
}

// WithRetryExitCodeOnPanic specified code for exit on panic
// If nil - no exiting on panic
func WithRetryExitCodeOnPanic(code *int) RetryComposeOption {
	return func(o *retryComposeOptions) {
		o.exitCodeOnPanic = code
	}
}

// Compose returns a new Retry which has functional fields composed both from t and x.
func (t Retry) Compose(x Retry, opts ...RetryComposeOption) (ret Retry) {
	options := retryComposeOptions{
		recoverPanicWriter: os.Stderr,
	}
	for _, opt := range opts {
		opt(&options)
	}
	{
		h1 := t.OnRetry
		h2 := x.OnRetry
		ret.OnRetry = func(r RetryLoopStartInfo) func(RetryLoopIntermediateInfo) func(RetryLoopDoneInfo) {
			if options.recoverPanic {
				defer func() {
					if e := recover(); e != nil {
						if options.recoverPanicWriter != nil {
							fmt.Fprintf(options.recoverPanicWriter, "panic recovered:%v:\n%s", e, debug.Stack())
						}
						if options.exitCodeOnPanic != nil {
							os.Exit(*options.exitCodeOnPanic)
						}
					}
				}()
			}
			var r1, r2 func(RetryLoopIntermediateInfo) func(RetryLoopDoneInfo)
			if h1 != nil {
				r1 = h1(r)
			}
			if h2 != nil {
				r2 = h2(r)
			}
			return func(r RetryLoopIntermediateInfo) func(RetryLoopDoneInfo) {
				if options.recoverPanic {
					defer func() {
						if e := recover(); e != nil {
							if options.recoverPanicWriter != nil {
								fmt.Fprintf(options.recoverPanicWriter, "panic recovered:%v:\n%s", e, debug.Stack())
							}
							if options.exitCodeOnPanic != nil {
								os.Exit(*options.exitCodeOnPanic)
							}
						}
					}()
				}
				var r3, r4 func(RetryLoopDoneInfo)
				if r1 != nil {
					r3 = r1(r)
				}
				if r2 != nil {
					r4 = r2(r)
				}
				return func(r RetryLoopDoneInfo) {
					if options.recoverPanic {
						defer func() {
							if e := recover(); e != nil {
								if options.recoverPanicWriter != nil {
									fmt.Fprintf(options.recoverPanicWriter, "panic recovered:%v:\n%s", e, debug.Stack())
								}
								if options.exitCodeOnPanic != nil {
									os.Exit(*options.exitCodeOnPanic)
								}
							}
						}()
					}
					if r3 != nil {
						r3(r)
					}
					if r4 != nil {
						r4(r)
					}
				}
			}
		}
	}
	return ret
}
func (t Retry) onRetry(r RetryLoopStartInfo) func(RetryLoopIntermediateInfo) func(RetryLoopDoneInfo) {
	fn := t.OnRetry
	if fn == nil {
		return func(RetryLoopIntermediateInfo) func(RetryLoopDoneInfo) {
			return func(RetryLoopDoneInfo) {
				return
			}
		}
	}
	res := fn(r)
	if res == nil {
		return func(RetryLoopIntermediateInfo) func(RetryLoopDoneInfo) {
			return func(RetryLoopDoneInfo) {
				return
			}
		}
	}
	return func(r RetryLoopIntermediateInfo) func(RetryLoopDoneInfo) {
		res := res(r)
		if res == nil {
			return func(RetryLoopDoneInfo) {
				return
			}
		}
		return res
	}
}
func RetryOnRetry(t Retry, c *context.Context, iD string, idempotent bool) func(error) func(attempts int, _ error) {
	var p RetryLoopStartInfo
	p.Context = c
	p.ID = iD
	p.Idempotent = idempotent
	res := t.onRetry(p)
	return func(e error) func(int, error) {
		var p RetryLoopIntermediateInfo
		p.Error = e
		res := res(p)
		return func(attempts int, e error) {
			var p RetryLoopDoneInfo
			p.Attempts = attempts
			p.Error = e
			res(p)
		}
	}
}
