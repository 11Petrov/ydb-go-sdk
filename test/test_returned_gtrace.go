// Code generated by gtrace. DO NOT EDIT.

package test

// Compose returns a new TraceReturningTrace which has functional fields composed
// both from t and x.
func (t TraceReturningTrace) Compose(x TraceReturningTrace) (ret TraceReturningTrace) {
	switch {
	case t.OnReturnedTrace == nil:
		ret.OnReturnedTrace = x.OnReturnedTrace
	case x.OnReturnedTrace == nil:
		ret.OnReturnedTrace = t.OnReturnedTrace
	default:
		h1 := t.OnReturnedTrace
		h2 := x.OnReturnedTrace
		ret.OnReturnedTrace = func() ReturnedTrace {
			r1 := h1()
			r2 := h2()
			switch {
			case r1.isZero():
				return r2
			case r2.isZero():
				return r1
			default:
				return r1.Compose(r2)
			}
		}
	}
	return ret
}
func (t TraceReturningTrace) onReturnedTrace() ReturnedTrace {
	fn := t.OnReturnedTrace
	if fn == nil {
		return ReturnedTrace{}
	}
	res := fn()
	return res
}

// Compose returns a new ReturnedTrace which has functional fields composed
// both from t and x.
func (t ReturnedTrace) Compose(x ReturnedTrace) (ret ReturnedTrace) {
	switch {
	case t.OnSomething == nil:
		ret.OnSomething = x.OnSomething
	case x.OnSomething == nil:
		ret.OnSomething = t.OnSomething
	default:
		h1 := t.OnSomething
		h2 := x.OnSomething
		ret.OnSomething = func() {
			h1()
			h2()
		}
	}
	return ret
}

// isZero checks whether t is empty
func (t ReturnedTrace) isZero() bool {
	if t.OnSomething != nil {
		return false
	}
	return true
}
func (t ReturnedTrace) onSomething() {
	fn := t.OnSomething
	if fn == nil {
		return
	}
	fn()
}
func traceReturningTraceOnReturnedTrace(t TraceReturningTrace) ReturnedTrace {
	res := t.onReturnedTrace()
	return res
}
